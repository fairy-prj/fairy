      super
    end

    def node_class_name
      "NLFileInput"
    end

    def start(job)
      @job = job
      super()
    end

    def create_and_start_nodes
      if @opts[:split_size]
	create_and_start_nodes_split
      else
	create_and_start_nodes1
      end
    end

    def create_and_start_nodes1
      begin
	no = 0
	@create_node_mutex.synchronize do
	  nlfileinput = nil
	  @controller.assign_new_processor(self) do |processor|
	    nlfileinput = create_node(processor)
	  end
	  no = 1
	  Thread.start do
	    @job.open do |io|
	      nlfileinput.open(io)
	      wait_input_finished(nlfileinput)
	    end
	  end
	end
      rescue BreakCreateNode
	# do nothing
	Log::debug self, "BREAK CREATE NODE: #{self}" 
      ensure
	self.number_of_nodes = no
      end
      nil
    end

    def create_and_start_nodes_split
      begin
	no_nodes = 0
	@job.split_opens(@opts[:split_size]) do |io|
	  @create_node_mutex.synchronize do
	    no_nodes += 1
	    nlfileinput = nil
	    @controller.assign_new_processor(self) do |processor|
	      nlfileinput = create_node(processor)
	    end
	    Thread.start(nlfileinput) do |nlfi|
	      begin
		nlfi.open(io)
		wait_input_finished(nlfi)
	      ensure
		io.close
	      end
	    end
	  end
	end
      rescue BreakCreateNode
	# do nothing
	Log::debug self, "BREAK CREATE NODE: #{self}" 
      ensure
	self.number_of_nodes = no_nodes
      end
    end

    def wait_input_finished(njob)
      while !njob_input_finished?(njob)
	@nodes_status_mutex.synchronize do
	  @nodes_status_cv.wait(@nodes_status_mutex)
	end
      end
    end

    def njob_input_finished?(njob)
      return false
      st = @nodes_status[njob]
      [:ST_WAIT_EXPORT_FINISH, :ST_EXPORT_FINISH, :ST_FINISH, :ST_OUTPUT_FINISH].include?(st)
    end

  end
end

require "backend/boutput"

module Fairy
  class BLFileOutput<BOutput
    Controller.def_export(self)

    def initialize(controller, opts=nil)
      @imports = Queue.new
      super
    end

    def output(job)
      @job = job
    end

    def node_class_name
      "NLFileOutput"
    end

    def create_nodes
      no = 0
      input_processors = {}
      @input.each_export do |input_export, input_njob|
	if njob = input_processors[input_njob.processor]
	  njob.add_input(input_export)
	else
	  njob = create_and_add_node(input_export, input_njob)
	  input_processors[njob.processor] = njob
	  no += 1

	  import = Import.new
	  @imports.push import
	  njob.export.output = import
	  import.no_import = 1
	end
      end
      for p, njob in input_processors
	njob.add_input(nil)
      end
      self.number_of_nodes = no

      @imports.push nil
    end

    def each(&block)
      while import = @imports.pop
	import.each do |e|
	  block.call e
	end
      end
    end

    def wait_all_output_finished
      while !all_node_outputted?
	@nodes_status_mutex.synchronize do
	  @nodes_status_cv.wait(@nodes_status_mutex)
	end
      end
    end

    def all_node_outputted?
      return false unless @number_of_nodes

      all_outputted = true
      each_node(:exist_only) do |node|
	st = @nodes_status[node]
	all_outputted &= [:ST_FINISH, :ST_OUTPUT_FINISH].include?(st)
      end
      all_outputted
    end

  end
end

require "controller"
require "backend/boutput"

require "share/varray"

module Fairy
  class BOutputVArray<BOutput
    Controller.def_export self

    def initialize(controller, opts)
      super
      @varray = VArray.new

      @node_id = 0
    end

    attr_reader :varray

    def node_class_name
      "NOutputVArray"
    end

    def njob_creation_params
      @node_id += 1
      [@node_id-1]
#      []
    end

    def number_of_nodes=(no_nodes)
      super
      ary = Array.new(no_nodes)
      @varray.set_arrays(ary)
    end

    def wait_all_output_finished
      @nodes_status_mutex.synchronize do
	while !all_node_outputted?
	  @nodes_status_cv.wait(@nodes_status_mutex)
	end
      end
    end

    def all_node_outputted?
      return false unless @nodes_mutex.synchronize{@number_of_nodes}

      each_node(:exist_only) do |node|
	st = @nodes_status[node]
	return false unless [:ST_FINISH, :ST_OUTPUT_FINISH].include?(st)
      end
      true
    end

  end
end

require "delegate"

require "backend/bjob"

module Fairy
  class BShuffle<BFilter
    Controller.def_export self

#    include BInputtable

    def initialize(controller, opts, block_source)
      super
#      @block = @context.create_proc(@block_source.source)

      @input2node = {}
      @input_queue = PortQueue.new
      @output_queue = PortQueue.new

      @block_source = block_source
      @begin_block_source = nil
      if @opts[:BEGIN]
	@begin_block_source = @opts[:BEGIN]
      end
      @end_block_source = nil
      if @opts[:END]
	@end_block_source = @opts[:END]
      end

    end

    def input=(input)
      @input = input
      start_get_exports
      start
    end

    def start_get_exports
      Thread.start do
	@input.each_export do |export, node|
	  @input2node[export] = node
	  @input_queue.push export
	end
	@input_queue.push nil
      end
    end

    def start
      Thread.start do
	if @begin_block_source
	  bsource = BScript.new(@begin_block_source, @context, self)
	  bsource.evaluate
	end
	@block = BBlock.new(@block_source, @context, self)
	begin
	  @block.call(@input_queue, @output_queue)
	  @output_queue.push nil
	ensure
	  if @end_block_source
	    bsource = BSource.new(@end_block_source, @context, self)
	    bsource.evaluate
	  end
	end
      end
      nil
    end

    def each_export(&block)
      for exp in @output_queue
	node = @input2node[exp]
	block.call exp, node
      end
    end

    class PortQueue<DelegateClass(Queue)
      include Enumerable

      def initialize
	super(Queue.new)
      end

      def each
	while e = pop
	  yield e
	end
      end
    end
  end
end

require "backend/b-filter"
require "backend/b-inputtable"

module Fairy
  class BSplitter<BFilter
    Controller.def_export self

#    DeepConnect.def_single_method_spec(self, "REF new(REF, VAL, VAL)")

    def initialize(controller, opts, n)
      super
      @no_split = n

      @no_of_exports = 0

#       @exports = []
#       @exports_mutex = Mutex.new
#       @exports_cv = ConditionVariable.new

#       @exports_queue = Queue.new
    end

    def start_create_nodes
      super

    end

    def each_export(&block)
      each_node do |node|
	for exp in node.exports
	  exp.no = @no_of_exports
	  @no_of_exports += 1
	  block.call exp, node
	  exp.output_no_import = 1
	end
      end

    end

    def node_class_name
      "NSplitter"
    end
    
    def njob_creation_params
      [@no_split]
    end
  end
end

require "controller"
require "backend/binput"

module Fairy
  class BThere<BInput
    Controller.def_export self

    def initialize(controller, opts, enumerable)
      super
      @enumerable = enumerable
    end

    def node_class_name
      "NThere"
    end

    def njob_creation_params
      [@enumerable]
    end

    def create_and_start_nodes
      begin
	no = 0
	@create_node_mutex.synchronize do
	  nthere = nil
	  @controller.assign_new_processor(self) do |processor|
	    nthere = create_node(processor)
	  end
	  no += 1
	  nthere.start
	end
      rescue BreakCreateNode
	# do nothing
	Log::debug self, "BREAK CREATE NODE: #{self}" 
      ensure
	self.number_of_nodes = no
      end
    end
  end
end


      

require "backend/b-filter"
require "backend/b-inputtable"

module Fairy
  class BZipper<BFilter
    Controller.def_export self

    ZIP_BY_SUBSTREAM = :ZIP_BY_SUBSTREAM

    DeepConnect.def_single_method_spec(self, "REF new(REF, VAL, VAL, REF)")

    def initialize(controller, opts, others, block_source)
      super
      @others = others
      @block_source = block_source
    end

    def opt_zip_by_substream?
      @opts[ZIP_BY_SUBSTREAM]
    end

    def node_class_name
      "NZipper"
    end

    def njob_creation_params
      [@block_source]
    end

    def start_create_nodes
      @other_export_queues = @others.collect{|other|
	exports = Queue.new
	Thread.start do
	  other.each_export do |export, node|
	    exports.push export
	  end
	end
	exports
      }
      super
    end

    def create_and_add_node(export, node)
      node = super
      if opt_zip_by_substream?
	others = @other_export_queues.collect{|queue| queue.pop	}
	node.zip_inputs = others
	others.zip(node.zip_imports){|other, import| other.output = import}
      else
	raise "まだできていません"
      end
    end

    def break_running
      super
      @others.each{|others| Thread.start{others.break_running}}
    end
  end
end
require "uri"

require "controller"
require "backend/binput"
require "share/vfile"

module Fairy
  class BFile<BInput
    Controller.def_export self

    def BFile.open(controller, opts, descripter)
      bfile = BFile.new(controller, opts)
      bfile.open(desctipter)
      bfile
    end
    DeepConnect.def_single_method_spec(self, "REF open(REF, VAL, VAL)")

    URI_REGEXP = /:\/\//

    def node_class_name
      "NFile"
    end

    def open(vf)
      @vfile = vf
      start
    end
    DeepConnect.def_method_spec(self, "REF open(DVAL)")

    def create_and_start_nodes
      begin
	no = 0
 Log::debug self, "VFile: #{@vfile}"
	for file in @vfile
 Log::debug self, "File: #{file}"
	  @create_node_mutex.synchronize do
	    no +=1

	    host = "localhost"
	    path = file
	    if URI_REGEXP =~ file
	      uri = URI(file)
	      host = uri.host
	      if /^\[([0-9a-f.:]*)\]$/ =~ host
		host = $1
	      end
	      path = uri.path
	    end
	    @controller.assign_input_processor(self, host) do |processor|
	      node = create_node(processor)
	      node.open(path)
	    end
	  end
	end
      rescue BreakCreateNode
	# do nothing
	Log::debug self, "BREAK CREATE NODE: #{self}" 
      rescue Exception
	p $!
	Log::debug_exception(self)
	raise
      ensure
	Log::debug self, "CREATE_NODES: #{self}.number_of_nodes=#{no}"
	self.number_of_nodes = no
      end
    end
  end
end

require "backend/b-filter"
require "backend/b-inputtable"

require "node/port"


module Fairy
  class BHere<BFilter
    Controller.def_export self

    def initialize(controller, opts=nil)
      
      @imports = Queue.new
      super
    end

    def create_nodes
      super

      @imports.push nil
    end

    def create_and_add_node(export, bjob)
      node = super(export, bjob)
      import = Import.new
      @imports.push import
      node.export.output = import
      import.no_import = 1
    end

    def node_class_name
      "NHere"
    end

    def each(&block)
      while import = @imports.pop
	import.each do |e|
	  block.call e
	end
      end
    end
  end
end



require "backend/bjob"

module Fairy
  class BInput<BJob
    def initialize(*rests)
      super
      
      @create_node_thread = nil
      @create_node_mutex = Mutex.new
    end

    def output=(output)
      @output = output
    end

    def start
      @create_node_thread = Thread.start {
	create_and_start_nodes
      }
    end
  end
end

require "controller"

module Fairy
  class BJob
    Controller.def_export self

    @@watch_status = false
    def self.watch_status
      @@watch_status
    end

    def self.watch_status=(val)
      @@watch_status=val
    end

    DeepConnect.def_single_method_spec(self, "REF new(REF, VAL, *DEFAULT)")

    def initialize(controller, opts, *rests)
      Log::info self, "CREATE BJOB: #{self.class}"
      @controller = controller

      @opts = opts
      @opts = {} unless @opts

      @job_pool_dict = PoolDictionary.new

      @number_of_nodes = nil
#      @number_of_nodes_mutex = Mutex.new
#      @number_of_nodes_cv = ConditionVariable.new

      @nodes = []
      @nodes_mutex = Mutex.new
      @nodes_cv = ConditionVariable.new

      @nodes_status = {}
      @nodes_status_mutex = Mutex.new
      @nodes_status_cv = ConditionVariable.new

      @context = Context.new(self)

      start_watch_node_status if watch_status?
    end

    # プール変数
    def pool_dict
      @controller.pool_dict
    end

    def job_pool_dict
      @job_pool_dict
    end

    def def_job_pool_variable(vname, value = nil)
      @job_pool_dict.def_variable(vname, value)
    end

    def job_pool_variable(vname, *value)
      if value.empty?
	@job_pool_dict[vname]
      else
	@job_pool_dict[vname] = value
      end
    end

    #
    def create_node(processor, *params)
      if params.empty?
	params = njob_creation_params
      end
      njob = processor.create_njob(node_class_name, self, @opts, *params)
      add_node(njob)
      njob
    end
    
    def node_class_name
      raise "#{self.class}のNjobクラス名が登録されていません"
    end

    def njob_creation_params
      []
    end

    def number_of_nodes
#      @number_of_nodes_mutex.synchronize do
      @nodes_mutex.synchronize do
	while !@number_of_nodes
#	  @number_of_nodes_cv.wait(@number_of_nodes_mutex)
	  @nodes_mutex_cv.wait(@nodes_mutex)
	end
	@number_of_nodes
      end
    end

    def number_of_nodes=(no)
#puts "#{self}.number_of_nodes=#{no}"
#      @number_of_nodes_mutex.synchronize do
      @nodes_mutex.synchronize do
	@number_of_nodes = no
#	@number_of_nodes_cv.broadcast
	@nodes_cv.broadcast
	@nodes_status_cv.broadcast
      end
    end

    def nodes
      @nodes_mutex.synchronize do
	@nodes
      end
    end

    def add_node(node)
      @nodes_mutex.synchronize do
	node.no = @nodes.size
	@nodes.push node
	@nodes_cv.broadcast
      end
    end

    def each_node(flag = nil, &block)
      if flag == :exist_only
	return each_node_exist_only &block
      end
      @nodes_mutex.synchronize do
	idx = 0
	while !@number_of_nodes || idx < @number_of_nodes
	  unless @nodes[idx]
	    @nodes_cv.wait(@nodes_mutex)
	    next
	  end
	  block.call @nodes[idx] 
	  idx +=1
	end
      end
    end

    def each_node_exist_only(&block)
      nodes = @nodes_mutex.synchronize{@nodes.dup}
      nodes.each &block
    end

    def each_export(&block)
      each_node do |node|
	exp = node.export
	block.call exp, node
	node.export.output_no_import = 1
      end
    end

    def break_running(njob = nil)
      break_create_node
      
      each_node do |tasklet|
	tasklet.break_running unless tasklet.equal?(njob)
      end
    end

    def break_create_node
      # 作成中のものは完全に作成させるため
Log::debug self, "BREAK_CREATE_NODE: #1"
      @create_node_mutex.synchronize do
Log::debug self, "BREAK_CREATE_NODE: #2"
	@create_node_thread.raise BreakCreateNode
Log::debug self, "BREAK_CREATE_NODE: #3"
      end
Log::debug self, "BREAK_CREATE_NODE: #4"
    end

    def update_status(node, st)
      @nodes_status_mutex.synchronize do
	@nodes_status[node] = st
	@nodes_status_cv.broadcast
      end
    end

    def watch_status?
      @@watch_status
    end

    def start_watch_node_status
      Thread.start do

	all_finished = false
	while !@number_of_nodes || !all_finished
	  @nodes_status_mutex.synchronize do
	    @nodes_status_cv.wait(@nodes_status_mutex)
	  end

	  all_finished = @number_of_nodes
	  Log::info(self) do |sio|
	    sio.puts "Status Changed: BEGIN #{self}"
	    each_node(:exist_only) do |node|
	      st = @nodes_status[node]
	      sio.puts "  node: #{node} status: #{st.id2name}" if st
	      all_finished &&= st==:ST_FINISH
	    end
	    sio.puts "Status Changed: END #{self}"
	  end
	end
	Log::info self, "ALL NJOB finished"
      end
      nil
    end

    def handle_exception(exp)
      @controller.handle_exception(exp)
    end

    class Context
      def initialize(bjob)
	@Pool = bjob.instance_eval{pool_dict}
	@JobPool = bjob.instance_eval{job_pool_dict}
	@__context = context
      end

#      def create_proc(source)
#	eval("proc{#{source}}", binding)
#      end

      def context
	__binding
      end

      class GlobalBreak<Exception;end
      def global_break
	Thread.current.raise GlobalBreak
      end
      alias gbreak global_break

      alias __binding binding
      def binding
	@__context
      end
      alias bind binding
    end
  end
end

require "backend/bjob"
require "backend/b-inputtable"

module Fairy
  class BOutput<BJob
    include BInputtable

    def input=(input)
      @input = input
      input.output = @input
      super
    end

  end
end

require "backend/bfile"
require "backend/b-each-element-mapper"
require "backend/b-each-substream-mapper"
require "backend/b-each-element-selector"
require "backend/bhere"
require "backend/b-group-by"
require "backend/b-zipper"

module Fairy
  class JobInterpriter
    def initialize(controller)
      @controller = controller
    end

    def exec(atom)
      puts "SEND: #{atom.receiver}.#{atom.message}(#{atom.args.map{|e| e.to_s}.join(",")})"
      ret = atom.receiver.send(atom.message, *atom.args)
      # このあと何か必要か?
    end
  end
end


module Fairy
  class Scheduler

    def initialize(controller)
      # 取りあえず
      @controller = controller
      #@processors = [Processor.new]
    end
      

    def schedule(atom)
      # 取りあえず.
      # ここで, atomにはノード指定がすでにあるとしている.
      # 指定されたノードにスケジュールする.
      @processors[0].exec atom
    end
    
  end
end
#
#   accepter.rb - 
#   	$Release Version: $
#   	$Revision: 1.1 $
#   	$Date: 1997/08/08 00:57:08 $
#   	by Keiju ISHITSUKA(Penta Advanced Laboratories Co.,Ltd)
#
# --
#
#   
#

require "socket"
require "ipaddr"

require "deep-connect/event"

module DeepConnect
  class Accepter
    def initialize(org)
      @organizer = org
      @probe = nil
    end

    def port_number
      @probe.addr[1]
    end

    def open(service = 0)
      @probe = TCPServer.open("", service)
    end

    def start
      @probe_thread = Thread.start {
	loop do
	  sock = @probe.accept
	  Thread.start do
	    port = Port.new(sock)
	    begin
	      unless (ev = port.import).kind_of?(Event::InitSessionEvent)
		puts "WARN: 接続初期化エラー: [#{port.peeraddr}]"
	      end
	      begin
		@organizer.connect_deep_space_with_port port, ev.local_id
	      rescue ConnectCancel
		puts "INFO: クライアント(#{ev.local_id}からの接続を拒否しました."
	      rescue ConnectionRefused
		puts "WARN: クライアント(#{ev.local_id}への接続が拒否されました"
	      rescue ProtocolError, IOError
		puts "WARN: 接続初期化エラー: [#{port.peeraddr}]"

	      end
	    rescue EOFError
	      puts "WARN: 接続初期化中に[#{port.peeraddr}]との接続が切れました"
	    end
	  end
	end
      }
    end

    def stop
      @probe_thread.exit
      @probe.close
    end
  end
end

    

require "thread"
require "e2mmap"

module DeepConnect

  class ClassSpecSpace
    NULL = :NULL

    def initialize(remote = :remote)
      case remote
      when :remote
	@class_specs = nil
      when :local
	@class_specs = {}
      end

      @class_specs_mutex = Mutex.new
      @class_specs_cv = ConditionVariable.new

      @method_spec_cache = {}
    end

    def class_spec_id_of(obj)
      ancestors = obj.class.ancestors
      begin
	single = (class<<obj;self;end)
	ancestors.unshift single
      rescue
      end
#p ancestors
#      p ancestors.collect{|e| e.object_id}
      klass = ancestors.find{|kls|
	@class_specs[kls.object_id]
      }
      if klass
	klass.object_id
      else
	nil
