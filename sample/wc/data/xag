    def recv_keep_alive_impl
      puts "RECV_KEEP_ALIVE"  if DISPLAY_KEEP_ALIVE
      @last_keep_alive = @organizer.tick
    end
    Organizer.def_interface(self, :recv_keep_alive_impl)
  end
end


job_dir = File.dirname(__FILE__)
for job in Dir.glob("#{job_dir}/*.rb")
  next if job == __FILE__

#  puts "require #{job}"

  require job
end

require "job/filter"

require "share/block-source"

module Fairy
    module Interface
      def barrier(opts = nil)
	if opts[:cond].kind_of?(String)
	  opts[:cond] = BlockSource.new(opts[:cond])
	end
	barrier = Barrier.new(@fairy, opts)
	barrier.input = self
	barrier
      end
    end
    Fairy::def_job_interface Interface


  class Barrier<Filter
    def backend_class_name
      "BBarrier"
    end
  end
end

require "job/filter"
require "share/block-source"

module Fairy

  class EachElementMapper<Filter
    module Interface
      def map(block_source, opts = nil)
	raise "ブロックは受け付けられません" if block_given?
	block_source = BlockSource.new(block_source) 
	mapper = EachElementMapper.new(@fairy, opts, block_source)
	mapper.input=self
	mapper
      end
      alias collect map
     
    end
    Fairy::def_job_interface Interface

    def initialize(fairy, opts, block_source)
      super
      @block_source = block_source
    end

    def backend_class_name
      "BEachElementMapper"
    end
  end
end

require "job/filter"

module Fairy

  class EachElementSelector<Filter
    module Interface
      def select(block_source, opts = nil)
	raise "ブロックは受け付けられません" if block_given?
	block_source = BlockSource.new(block_source) 
	mapper = EachElementSelector.new(@fairy, opts, block_source)
	mapper.input=self
	mapper
      end

      alias find_all select

      def grep(regexp, opts = nil)
	select(%{|e| /#{regexp.source}/ === e}, opts)
      end
    end
    Fairy::def_job_interface Interface

    def initialize(fairy, opts, block_source)
      super
      @block_source = block_source
    end

    def backend_class_name
      "BEachElementSelector"
    end
  end

end

require "job/filter"

module Fairy

  class EachSubStreamMapper<Filter
    module Interface
      def smap(block_source, opts = nil)
	raise "ブロックは受け付けられません" if block_given?
	block_source = BlockSource.new(block_source) 
	mapper = EachSubStreamMapper.new(@fairy, opts, block_source)
	mapper.input=self
	mapper
      end

      # emap(%{|enum| enum.collect{..})
      def emap(block_source, opts = nil)
	raise "ブロックは受け付けられません" if block_given?
	map_source = %{|i, o| proc{#{block_source}}.call(i).each{|e| o.push e}}
	smap(map_source, opts)
      end
    end
    Fairy::def_job_interface Interface

    def initialize(fairy, opts, block_source)
      super
      @block_source = block_source
    end

    def backend_class_name
      "BEachSubStreamMapper"
    end
  end
end

require "job/job"
require "share/vfile"

module Fairy
  class FFileOutput < Job

    @backend_class = nil

    def FFileOutput.output(fairy, opts, vfn)
      ffile = new(fairy, opts)
      ffile.output(vfn)
      ffile
    end

    def initialize(fairy, opts=nil)
      super

      @vfile = nil
    end

    def backend_class_name
      "BFileOutput"
    end

    def output(vfn)
      @descripter = vfn
      @vfile = VFile.new
      @vfile.vfile_name = vfn
      backend.output(@vfile)

#      vf.create_vfile(vfn)
    end

    def input=(job)
      @input = job
      backend.input=job.backend

      backend.wait_all_output_finished
      @vfile.create_vfile
    end
  end

end

require "job/job"
require "share/vfile"

module Fairy
  class FFile < Job

    @backend_class = nil

    def FFile.open(fairy, opts, ffile_descripter)
      ffile = new(fairy, opts)
      ffile.open(ffile_descripter)
      ffile
    end

    def FFile.input(fairy, opts, ffile_descripter)
      FFile.open(fairy, opts, ffile_descripter)
    end

    def initialize(fairy, opts=nil)
      super
    end

    def backend_class_name
      "BFile"
    end

    def open(ffile_descripter)
      @descripter = ffile_descripter
      case ffile_descripter
      when Array
	vf = VFile.real_files(ffile_descripter)
      when VFile
	vf = ffile_descripter
      when String
	if VFile.vfile?(ffile_descripter)
	  vf = VFile.vfile(ffile_descripter)
	else
	  vf = VFile.real_files([ffile_descripter])
	end
      else
	raise "指定が間違っています"
      end
      backend.open(vf)
      self
    end

  end

#  class BFile;end
end

require "job/job"

module Fairy
  class Filter < Job

    def initialize(fairy, *rests)
      super
    end

    def backend_class_name
      raise "backend_classの名前を定義してください"
    end

    def input=(job)
      @input=job
#      atom = Atom.new(backend, :input=, job.backend)
#      @fairy.send_atom(atom)
      backend.input=job.backend
    end
  end
end

require "job/filter"

module Fairy
  class Find<Filter

    module Interface
      # filter.find(%{...})
      def find(block_source, opts = nil)
	block_source = BlockSource.new(block_source) 
	find = Find.new(@fairy, opts, block_source)
	find.input = self
	find
      end
    end
    Fairy::def_job_interface Interface

    def initialize(fairy, opts, block_source)
      super
      @block_source = block_source
    end

    def backend_class_name
      "BFind"
    end

    def value
      backend.value
    end
  end
end

require "job/filter"

module Fairy
  class GroupBy<Filter

    module Interface
      def group_by(hash_block, opts = nil)
	hash_block = BlockSource.new(hash_block) 
	group_by = GroupBy.new(@fairy, opts, hash_block)
	group_by.input = self
	group_by
      end
    end
    Fairy::def_job_interface Interface

    def initialize(fairy, opts, block_source)
      super
      @block_source = block_source
    end

    def backend_class_name
      "BGroupBy"
    end
  end

  class MGroupBy<Filter

    module Interface
      def mgroup_by(hash_block, opts = nil)
	hash_block = BlockSource.new(hash_block) 
	mgroup_by = MGroupBy.new(@fairy, opts, hash_block)
	mgroup_by.input = self
	mgroup_by
      end
    end
    Fairy::def_job_interface Interface

    def initialize(fairy, opts, block_source)
      super
      @block_source = block_source
    end

    def backend_class_name
      "BMGroupBy"
    end
  end
end
require "job/filter"

module Fairy
  class Here<Filter
    include Enumerable

    module Interface
      def here(opts = nil)
	here = Here.new(@fairy, opts)
	here.input= self
	here
      end
    end
    Fairy::def_job_interface Interface

    def initialize(fairy, opts = nil)
      super
    end

    def backend_class_name
      "BHere"
    end

    def each(&block)
      backend.each{|e| block.call e}
    end

    def to_a
      ary = []
      backend.each{|e| ary.push e}
      ary
    end

  end

#  class BHere;end
end

require "job/filter"

module Fairy
  class Inject<Filter

    module Interface
      # filter.inject(%{...}, :init_value = val)
      def inject(block_source, opts = nil)
	block_source = BlockSource.new(block_source) 
	inject = Inject.new(@fairy, opts, block_source)
	inject.input = self
	#DeepConnect::future{inject.value}
	inject
      end

      def min(block_source=nil, opts = nil)
	unless block_source
	  block_source = %{|e1, e2| e1 <=> e2}
	end
	
	inject(%{|r, v| (proc{#{block_source}}.call(r, v) < 0) ? r : v})
      end

      def min_by(block_source, opts = nil)
	pair = map(%{|v| [proc{#{block_source}}.call(v), v]})
	min_by = pair.inject(%{|r, v| ((r[0] <=> v[0]) < 0) ? r : v})
	def min_by.value
	  super[1]
	end
	min_by
      end

      def max(block_source=nil, opts = nil)
	unless block_source
	  block_source = %{|e1, e2| e1 <=> e2}
	end
	
	inject(%{|r, v| (proc{#{block_source}}.call(r, v) < 0) ? v : r})
      end

      def max_by(block_source, opts = nil)
	pair = map(%{|v| [proc{#{block_source}}.call(v), v]})
	max_by = pair.inject(%{|r, v| ((r[0] <=> v[0]) < 0) ? v : r})
	def max_by.value
	  super[1]
	end
	max_by
      end
    end
    Fairy::def_job_interface Interface

    def initialize(fairy, opts, block_source)
      super
      @block_source = block_source
    end

    def backend_class_name
      "BInject"
    end

    def value
      backend.value
    end
  end
end
module Fairy

  DEFAULT_SPLIT_NO = 4

  class Iota < Job
    module Interface

      # Usage:
      # fairy.iota(no)....
      #
      def iota(times, opts={})
	Iota.input(self, opts, times)
      end
      alias times iota
      
    end
    Fairy::def_fairy_interface Interface

    def self.input(fairy, opts, n)
      unless opts[:SPLIT_NO]
	opts[:SPLIT_NO] = DEFAULT_SPLIT_NO
      end
      iota = new(fairy, opts, n)
      iota.start
      iota
    end
    
    
    def backend_class_name
      "BIota"
    end

    def start
      backend.start
    end
  end
end


    
      
      
module Fairy

  class InputVArray < Job

    def self.input(fairy, opts, varray)
      input_va = new(fairy, opts, varray)
      input_va.start
      input_va
    end
    
    
    def backend_class_name
      "BInputVArray"
    end

    def start
      backend.start
    end
  end
end


    
      
      

require "share/varray"

module Fairy
  module InputInterface
    def input(desc, *opts)
      if opts.last.kind_of?(Hash)
	opts_h = opts.pop
      else
	opts_h = {}
      end

      case desc
#      when Enumerable
#	There.input(self, opts_h, desc, *opts)
      when VArray
	  InputVArray.input(self, opts_h, desc)
      when DeepConnect::Reference
	if desc.peer_class.name == "Fairy::VArray"
	  InputVArray.input(self, opts_h, desc)
	else
	  raise "まだサポートしていません(#{desc}, #{desc.peer_class})"
	end
      when Class
	desc.input(self, opts_h, *opts)
      else
	if !desc.kind_of?(String) || VFile.vfile?(desc)
	  FFile.input(self, opts_h, desc)
	else
	  LFileInput.input(self, opts_h, desc)
	end
      end
    end
  end
  def_fairy_interface InputInterface
end




module Fairy

  def self.def_job_interface(mod)
    Job.instance_eval{include mod}
  end

  def Fairy.def_job_interface(mod)
    Job.instance_eval{include mod}
  end

  class Job
    def initialize(fairy, opts, *rests)
      @fairy = fairy
      @opts = opts
      @opts = {} unless @opts
      if @opts[:BEGIN]
	@opts[:BEGIN] = BlockSource.new(@opts[:BEGIN])
      end
      if @opts[:END]
	@opts[:END] = BlockSource.new(@opts[:END])
      end
      @ref = backend_class.new(fairy.controller, opts, *rests)
    end

    def backend_class
      unless klass = @fairy.name2backend_class(backend_class_name)
	raise "バックエンドクラス#{backend_class_name}が分かりません"
      end
      klass
    end

    def backend
      @ref
    end

    def backend=(v)
      @ref=v
    end

    def def_pool_variable(vname, value = nil)
      backend.def_pool_variable(vname, value)
    end

  end
end

require "job/job"
require "share/vfile"

module Fairy
  class LFileInput < Job

    def self.input(fairy, opts, filename)
      self.start(fairy, opts, filename)
    end

    def self.start(fairy, opts, filename)
      lfile = new(fairy, opts)
      lfile.start(filename)
      lfile
    end

    def initialize(fairy, opts=nil)
      super
      @io = nil
    end

    attr_reader :io

    def backend_class_name
      "BLFileInput"
    end

    def start(filename)
      @filename = filename
      backend.start(self)
    end

    def open
      if block_given?
	io = File.open(@filename)
	begin
	  yield io
	ensure
	  io.close
	end
      else
	File.open(@filename)
      end
    end

    def split_opens(split_size, &block)
      begin
	seek = 0
	size = File.stat(@filename).size
	while seek < size
	  io = SplittedFile.open(@filename, seek, seek += split_size)
	  yield io
	end
      rescue
	Log::warn_exception(self)
	raise
      end
    end

    class SplittedFile
      def self.open(fd, seek_start, seek_end, &block)
	sf = new(fd, seek_start, seek_end)
	if block_given?
	  begin
	    yield sf
	  ensure
	    sf.close
	  end
	else
	  sf
	end
      end

      def initialize(fd, seek_start, seek_end)

	@io = File.open(fd)
	@seek_start = seek_start
	@seek_end = seek_end

	if seek_start > 0
	  @io.seek(seek_start-1)
	  if /^$/ !~ @io.read(1)
	    # 一行空読みする
	    @io.gets
	  end
	end
	@io
      end

      def close
	@io.close
	@io = nil
      end

      def each(&block)
	begin
	  while @io.pos < @seek_end && l = @io.gets
	    yield l
	  end
	rescue
	  Log::warn_exception(self)
	  raise
	end
      end
    end
  end
end

require "job/job"
require "share/vfile"

module Fairy
  class LFileOutput < Job

    @backend_class = nil

    def LFileOutput.output(fairy, opts, filename)
      ffile = new(fairy, opts)
      ffile.output(filename)
      ffile
    end

    def initialize(fairy, opts=nil)
      super
      @opts = opts
      
      @filename = nil      
    end

    def backend_class_name
      "BLFileOutput"
    end

    def output(filename)
      @filename = filename
      backend.output(self)

    end

    def input=(job)
      @input = job
      backend.input=job.backend
      
      File.open(@filename, "w") do |io|
	for l in backend
	  io.puts l
	end
      end
    end
  end
end

require "job/job"
require "share/varray"

module Fairy
  class OutputVArray<Job
    module Interface
      # Usage:
      # ... .to_va
      #
      def to_va
	output_va = OutputVArray.output(@fairy, opts=nil)
	output_va.input = self
	output_va.varray
      end
    end
    Fairy::def_job_interface Interface
    
    def self.output(fairy, opts)
      output = new(fairy, opts)
      output
    end

    def initialize(fairy, opts=nil)
      super

      @varray = backend.varray
    end

    attr_reader :varray

    def backend_class_name
      "BOutputVArray"
    end

    def output
      backend.output
    end

    def input=(job)
      @input = job
      backend.input=job.backend
#      backend.wait_all_output_finished
    end
  end
end
module Fairy
  
  module OutputInterface
    def output(vfn, opts = nil)
      if vfn.kind_of?(Class)
	outputter = vfn.output(@fairy, opts)
      elsif !vfn.kind_of?(String) || VFile.vfile?(vfn)
	outputter = FFileOutput.output(@fairy, opts, vfn)
      else
	outputter = LFileOutput.output(@fairy, opts, vfn)
      end
      outputter.input = self
      outputter

    end
  end
  def_job_interface OutputInterface

end

require "job/ffile-output"
require "job/local-file-output"



require "job/filter"

module Fairy
  class Shuffle<Filter
    module Interface
      def shuffle(block_source, opts = nil)
	block_source = BlockSource.new(block_source) 
	shuffle = Shuffle.new(@fairy, opts, block_source)
	shuffle.input = self
	shuffle
      end
      alias sshuffle shuffle

      def eshuffle(block_source, opts = nil)
	map_source = %{|i, o| proc{#{block_source}}.call(i).each{|e| o.push e}}
	shuffle(map_source, opts)
      end
    end
    Fairy::def_job_interface Interface

    def initialize(fairy, opts, block_source)
      super
      @block_source = block_source
      @opts = opts
    end

    def backend_class_name
      "BShuffle"
    end
  end
end

require "job/filter"

module Fairy
  class Splitter<Filter
    module Interface
      def split(n, opts=nil)
	splitter = Splitter.new(@fairy, opts, n)
	splitter.input = self
	splitter
      end
    end
    Fairy::def_job_interface Interface


    def initialize(fairy, opts, n)
      super
      @no_split = n
      @opts = opts
    end

    def backend_class_name
      "BSplitter"
    end
  end
end

module Fairy
  class There < Job
    module Interface

      # Usage:
      # ○ fairy.there(enumeratable)....
      # ○ enumerable.there(fairy)....
      #    enumerable | fairy.there
      def there(enumerable = nil, opts={})
	There.input(self, opts, enumerable)
      end
    end
    Fairy::def_fairy_interface Interface

    Enumerable.module_eval %{def there(fairy); fairy.there(self); end}

    def self.input(fairy, opts, enumerable)
      self.start(fairy, opts, enumerable)
    end

    def self.start(fairy, opts, enumerable)
      there = new(fairy, opts, enumerable)
      there.start
      there
    end

    def initialize(fairy, opts, enumerable)
      super
      @enumerable = enumerable
    end

    def backend_class_name
      "BThere"
    end

    def start
      backend.start
    end
  end
end

require "job/filter"

module Fairy
  class Zipper<Filter

    module Interface
      # jpb.zip(opts,...,filter,...,block_source, opts,...)
      def zip(*others)
	block_source = nil
	if others.last.kind_of?(String)
	  block_source = others.pop
	end
	others, opts = others.partition{|e| e.kind_of?(Job)}
	if opts.last.kind_of?(Hash)
	  h = opts.pop
	else
	  h = {}
	end
	opts.each{|e| h[e] = true}

	block_source = BlockSource.new(block_source) 
	zip = Zipper.new(@fairy, h, others, block_source)
	zip.input = self
	zip
      end
    end
    Fairy::def_job_interface Interface

    ZIP_BY_SUBSTREAM = :ZIP_BY_SUBSTREAM

    def initialize(fairy, opts, others, block_source)
      super(fairy, opts, others.collect{|o| o.backend}, block_source)
      @others = others
      @block_source
      @opts = opts
    end

    def backend_class_name
      "BZipper"
    end
  end
end


njob_dir = File.dirname(__FILE__)
for njob in Dir.glob("#{njob_dir}/*.rb")
  next if njob == __FILE__

#  puts "require #{job}"

  require njob
end

require "node/njob"
require "node/n-single-exportable"

module Fairy
  class NBarrierMemoryBuffer<NSingleExportFilter
    Processor.def_export self

    def initialize(processor, bjob, opts=nil)
      @export = Export.new(Queue.new)
      super
    end

    def input=(input)
      unless @import
	@import = Import.new(Queue.new)
	@import.no=input.no
	@import.add_key(input.key)
	start
      end
      self
    end

    def start
      super do
	@bjob.wait_export
	@import.each{|e| @export.push e}
      end
    end
  end

end

require "node/n-filter"
require "node/n-single-exportable"
