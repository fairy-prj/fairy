	  start_process_life_manage
	end
	nil
      end
    end

    def connect(client)
      @client = client
      
      $stdout = Stdout.new(@client)
    end

    def terminate
      # clientが終了したときの終了処理
      # master から呼ばれる
      processors = @reserves.keys
      processors.each do |p| 
	begin
	  p.node.terminate_processor(p)
	rescue
#	  p $!, $@
	end
      end

      Thread.start do
	sleep 0.1
	@deepconnect.stop
	Process.exit(0)
      end
      nil
    end

    def when_disconnected(deepspace, opts)
      if deepspace == @client.deep_space
	Log::info(self, "CONTROLLER: disconnected: Start termination")
	# クライアントがおなくなりになったら, こっちも死ぬよ
	@master.terminate_controller(self)
      end
    end

    # 
    # clent interface
    #
    def export(service, obj)
      @services[service] = obj
    end

    def import(service)
      @services[service]
    end

    #
    # processor methods
    #
    # reserve してから njob 割り当てを行う
    def reserve_processor(processor, &block)
      @reserves_mutex.synchronize do
	begin
	  return nil unless @reserves[processor]
	rescue SessionServiceStopped
	  # processor は 終了している可能性がある
	  return nil
	end
	@reserves[processor] += 1
      end
      begin
	yield processor
	processor
      ensure
	@reserves_mutex.synchronize do
	  @reserves[processor] -= 1
	end
      end
    end

    def create_processor(node, bjob, &block)
      processor = node.create_processor
      processor.set_stdout(self)
      @reserves_mutex.synchronize do
	@reserves[processor] = 1
      end
      begin
	register_processor(bjob, processor)
	yield processor
	processor
      ensure
	@reserves_mutex.synchronize do
	  @reserves[processor] -= 1
	end
      end
    end

    def register_processor(bjob, processor)
      @bjob2processors_mutex.synchronize do
	@bjob2processors[bjob] = [] unless @bjob2processors[bjob]
	unless @bjob2processors[bjob].include?(processor)
	  @bjob2proce