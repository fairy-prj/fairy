
module Fairy
  class NEachElementMapper<NSingleExportFilter
    Processor.def_export self

    def initialize(processor, bjob, opts, block_source)
      super
      @block_source = block_source
#      @map_proc = eval("proc{#{@block_source}}", TOPLEVEL_BINDING)
#      @map_proc = @context.create_proc(@block_source)
    end

    def start
      super do
	@map_proc = BBlock.new(@block_source, @context, self)
	@import.each do |e|
	  @export.push @map_proc.yield(e)
	end
      end
    end
  end
end

require "node/n-filter"

module Fairy
  class NEachElementSelector<NSingleExportFilter
    Processor.def_export self

    def initialize(processor, bjob, opts, block_source)
      super
      @block_source = block_source
#      @map_proc = eval("proc{#{@block_source}}", TOPLEVEL_BINDING)
#      @map_proc = @context.create_proc(@block_source)
    end

    def start
      super do
	@map_proc = BBlock.new(@block_source, @context, self)
	@import.each do |e|
	  if @map_proc.yield(e)
	    @export.push e
	  end
	end
      end
    end
  end
end

require "node/njob"
require "node/n-single-exportable"

module Fairy
  class NEachSubStreamMapper<NSingleExportFilter
    Processor.def_export self

    def initialize(processor, bjob, opts, block_source)
      super
      @block_source = block_source
#      @map_proc = eval("proc{#{@block_source}}", TOPLEVEL_BINDING)
#      @map_proc = @context.create_proc(@block_source)
    end

    def start
      super do
	@map_proc = BBlock.new(@block_source, @context, self)
	@map_proc.yield(@import, @export)
      end
    end
  end

end

require "uri"

require "node/n-filter"

module Fairy
  class NFileOutput<NFilter
    Processor.def_export self
    
    ST_OUTPUT_FINISH = :ST_OUTPUT_FINISH

    def initialize(processor, bjob, opt, vf)
      super
      @vfile = vf

      @imports = Queue.new
    end

    def input=(input)
      super
      @imports.push @import
    end

    def add_input(input)
      unless input
	@imports.push nil
	return self
      end
      import = Import.new
      import.add_key(input.key)
      input.output = import
      @imports.push import
      self
    end

    def start
      output_uri = @vfile.gen_real_file_name(@processor.addr)
      output_file = URI.parse(output_uri).path

      super do
	File.open(output_file, "w") do |io|
	  while import = @imports.pop
	    for l in import
	      io.puts l
	    end
	  end
	end
	self.status = ST_OUTPUT_FINISH
      end
    end
  end
end

require "node/njob"
require "node/port"

module Fairy
  class NFilter<NJob
    Processor.def_export self

    ST_WAIT_IMPORT = :ST_WAIT_IMPORT

    def initialize(processor, bjob, opts=nil, *rests)
      super
      @import = nil

      self.status=ST_WAIT_IMPORT
    end

    attr_reader :import

    def input=(input)
      unless @import
	self.no = input.no
	@import = Import.new
	@import.no=input.no
	@import.add_key(input.key)
	start
      end
      self
    end
  end
end

require "node/n-filter"

module Fairy
  class NLocalFind<NSingleExportFilter
    Processor.def_export self

    def initialize(processor, bjob, opts, block_source)
      super
      @block_source = block_source
      @map_proc = BBlock.new(@block_source, @context, self)

      @find = false
      @find_mutex = Mutex.new
    end

    def start
      super do
	@import.each do |e|
	  # 見つかっていたら空読み
	  @find_mutex.synchronize do
	    next if @find 
	    next unless find = @map_proc.yield(e)
	    @export.push e
	  end
	end
      end
    end

    def find_break
      @find_mutex.synchronize do
	@find = true
      end
    end
  end


  class NFindResult<NSingleExportFilter
    Processor.def_export self

    def initialize(*args)
      super

      @value = :__FAIRY_NO_VALUE__
      @value_mutex = Mutex.new
      @value_cv = ConditionVariable.new
    end

    def value
      @value_mutex.synchronize do
	while @value == :__FAIRY_NO_VALUE__
	  @value_cv.wait(@value_mutex)
	end
	@value
      end
    end

    def start
      super do
	find = false
	@import.each do |e|
	  # 最初の要素以外空読み
	  next if find 
	  find = e

	  @value = find
	  @value_cv.broadcast 
	  @export.push find
	  # ちょっと気になる...
	  @export.push END_OF_STREAM

	  @bjob.update_find
	end
      end
    end
  end
end

require "node/n-filter"

module Fairy
  class NGroupBy<NFilter
    Processor.def_export self

    ST_WAIT_EXPORT_FINISH = :ST_WAIT_EXPORT_FINISH
    ST_EXPORT_FINISH = :ST_EXPORT_FINISH

    def initialize(processor, bjob, opts, block_source)
      super
      @block_source = block_source
#      @hash_proc = eval("proc{#{@block_source}}", TOPLEVEL_BINDING)
#      @hash_proc = @context.create_proc(@block_source)

      @exports = {}
      @exports_queue = Queue.new

      start_watch_exports
    end

    def add_export(key, export)
      @exports[key] = export
      @exports_queue.push [key, export]
    end

    def start
      super do
	@hash_proc = BBlock.new(@block_source, @context, self)
	begin
	  @import.each do |e|
	    key = @hash_proc.yield(e)
	    export = @exports[key]
	    unless export
	      export = Export.new
	      export.add_key(key)
	      add_export(key, export)
	    end
	    export.push e
	  end
	ensure
	  @exports.each{|key, export| export.push END_OF_STREAM}
	  wait_export_finish
	end
      end
    end

    def wait_export_finish

      # すべての, exportのoutputが設定されるまで待っている
      # かなりイマイチ
      for key, export in @exports
	export.output
      end

      # ここの位置が重要
      self.status = ST_WAIT_EXPORT_FINISH
      # ここもいまいち
      for key,  export in @exports
	export.wait_finish
      end
      self.status = ST_EXPORT_FINISH
    end

    def start_watch_exports
      Thread.start do
	loop do
	  key, export = @exports_queue.pop
	  notice_exports(key, export)
	end
      end
      nil
    end

    def notice_exports(key, export)
      @bjob.update_exports(key, export, self)
    end
  end

  class NMGroupBy<NFilter
    Processor.def_export self

    ST_WAIT_EXPORT_FINISH = :ST_WAIT_EXPORT_FINISH
    ST_EXPORT_FINISH = :ST_EXPORT_FINISH

    def initialize(processor, bjob, opts, block_source)
      super
      @block_source = block_source
#      @hash_proc = eval("proc{#{@block_source}}", TOPLEVEL_BINDING)
#      @hash_proc = @context.create_proc(@block_source)
      @hash_proc = BBlock.new(@block_source, @context, self)

      @exports = {}
      @exports_queue = Queue.new

      start_watch_exports
    end

    def add_export(key, export)
      @exports[key] = export
      @exports_queue.push [key, export]
    end

    def start
      super do
	@import.each do |e|
	  keys = @hash_proc.yield(e)
	  keys = [keys] unless keys.kind_of?(Array)
	  
	  for key in keys 
	    export = @exports[key]
	    unless export
	      export = Export.new
	      export.add_key(key)
	      add_export(key, export)
	    end
	    export.push e
	  end
	end
	@exports.each{|key, export| export.push END_OF_STREAM}
	wait_export_finish
      end
    end

    def wait_export_finish

      # すべての, exportのoutputが設定されるまで待っている
      # かなりイマイチ
      for key, export in @exports
	export.output
      end

      # ここの位置が重要
      self.status = ST_WAIT_EXPORT_FINISH
      # ここもいまいち
      for key,  export in @exports
	export.wait_finish
      end
      self.status = ST_EXPORT_FINISH
    end

    def start_watch_exports
      Thread.start do
	loop do
	  key, export = @exports_queue.pop
	  notice_exports(key, export)
	end
      end
      nil
    end

    def notice_exports(key, export)
      @bjob.update_exports(key, export, self)
    end
  end
end



require "node/njob"
require "node/n-single-exportable"

module Fairy
  class NIdentity<NSingleExportFilter
    Processor.def_export self

    def initialize(processor, bjob, opts=nil)
      super
    end

    def start
      super do
	@import.each{|e| @export.push e}
      end
    end
  end

end

require "node/njob"
require "node/n-single-exportable"

module Fairy

  class NInject<NSingleExportFilter
    def initialize(processor, bjob, opts, block_source)
      super

      @init_value = :__FAIRY_NO_VALUE__
      if @opts.key?(:init_value)
	@init_value = @opts[:init_value]
      end
      @block_source = block_source
#      @inject_proc = @context.create_proc(@block_source)
    end

    def start
      super do
	@inject_proc = BBlock.new(@block_source, @context, self)
	sum = @init_value
	@import.each do |e|
	  if sum == :__FAIRY_NO_VALUE__
	    sum = e
	  else
	    sum = @inject_proc.yield(sum, e)
	  end
	end
	finish(sum)
      end
    end
  end

  class NLocalInject<NInject
    Processor.def_export self
    
    def finish(sum)
      @export.push sum
    end

  end

  class NWideInject<NInject
    Processor.def_export self

    def initialize(*args)
      super

      @value = :__FAIRY_NO_VALUE__
      @value_mutex = Mutex.new
      @value_cv = ConditionVariable.new
    end

    def value
      @value_mutex.synchronize do
	while @value == :__FAIRY_NO_VALUE__
	  @value_cv.wait(@value_mutex)
	end
	@value
      end
    end

    def finish(sum)
      @value = sum
      @value_cv.broadcast 
      if @export
	@export.push sum
      end
    end
  end
end

module Fairy
  class NIota<NSingleExportInput
    Processor.def_export self

    def initialize(processor, bjob, opts, first, last)
      super
      @first = first
      @last = last
    end

    def start
      super do
	for i in @first..@last
	  @export.push i
	end
      end
    end

  end
end


module Fairy
  class NInputVArray<NSingleExportInput
    Processor.def_export self

    def initialize(processor, bjob, opts, array)
      super
      @array = array
    end

    def start
      super do
	for i in @array
	  @export.push i
	end
      end
    end

  end
end


require "node/njob"
require "node/n-single-exportable"

module Fairy
  class NLFileInput<NSingleExportInput
    Processor.def_export self

    def self.open(processor, bjob, io, opts=nil)
      nlfileinput = self.new(processor, bjob, opts)
      nlfileinput.open(job)
    end

    def initialize(processor, bjob, opts=nil)
      super
    end

    def open(io)
      @io = io
      start
      self
    end

    def start
      super do
	for l in @io
	  @export.push l
	end
      end
    end
  end
end

require "uri"

require "node/n-filter"

module Fairy
  class NLFileOutput<NSingleExportFilter
    Processor.def_export self

    ST_OUTPUT_FINISH = :ST_OUTPUT_FINISH

    def initialize(processor, bjob, opts=nil)
      super

      @imports = Queue.new
    end

    def input=(input)
      super
      @imports.push @import
    end

    def add_input(input)
      unless input
	@imports.push nil
	return self
      end
      import = Import.new
      import.no=(input.no)
      import.add_key(input.key)
      input.output = import
      @imports.push import
      self
    end

    def start
      super do
	while import = @imports.pop
	  for l in import
	    @export.push l
	  end
	end
      end
    end
  end
end

require "node/n-filter"

require "share/varray"

module Fairy
  class NOutputVArray<NFilter
    Processor.def_export self
    
    ST_OUTPUT_FINISH = :ST_OUTPUT_FINISH

#    DeepConnect.def_single_method_spec(self, "REF new(REF, REF, VAL, REF)")

#    def initialize(processor, bjob, opt, varray, idx)
    def initialize(processor, bjob, opt, idx)
      super
      @no_in_bjob = idx
    end

    def start
      super do
	array = []
	for l in @import
	  array.push l
	end
	
	@processor.register_varray_element(array)
	@bjob.varray.arrays_put(@no_in_bjob, array)
	self.status = ST_OUTPUT_FINISH
      end
    end
  end
end

require "node/n-filter"
 
module Fairy
  module NSingleExportable
    END_OF_STREAM = NJob::END_OF_STREAM

    ST_WAIT_EXPORT_FINISH = :ST_WAIT_EXPORT_FINISH
    ST_EXPORT_FINISH = :ST_EXPORT_FINISH

    def initialize(processor, bjob, opts=nil, *rests)
      super
      @export = Export.new unless @export
    end

    attr_reader :export

    def no=(no)
      super
      @export.no = no
    end

    def start(&block)
      super do
	begin
	  if @import
	    @export.add_key(@import.key)
	  end
	  block.call
	ensure
	  @export.push END_OF_STREAM
	  wait_export_finish
	end
      end
    end

    def wait_export_finish
      self.status = ST_WAIT_EXPORT_FINISH
      @export.wait_finish
      self.status = ST_EXPORT_FINISH
    end
  end

  class NSingleExportFilter<NFilter
    include NSingleExportable
  end


  class NSingleExportInput<NFilter
    include NSingleExportable
  end

end

require "node/n-filter"

module Fairy
  class NSplitter<NFilter
    Processor.def_export self

    DeepConnect.def_single_method_spec(self, "REF new(REF, VAL, VAL)")

    def initialize(processor, bjob, opts, n)
      super
      @no_split = n

      @exports = @no_split.times.collect{Export.new}
    end

    attr_reader :exports

    def start
      super do
	begin
	  @import.each_slice(@no_split) do |ll|
	    if ll.size < @no_split
	      ll.fill(0, @no_split){|idx| ll[idx] ||= END_OF_STREAM}
	    end
	    @exports.zip(ll) do |exp, l|
	      exp.push l
	    end
	  end
	ensure
	  @exports.each{|exp| exp.push END_OF_STREAM}
	end
      end
    end
  end
end

require "node/njob"
require "node/port"
require "node/n-single-exportable"

module Fairy
  class NThere<NJob
    Processor.def_export self

    include NSingleExportable


    def initialize(processor, bjob, opts, enumerable)
      super
      @enumerable = enumerable
    end

    def start
      super do
	@enumerable.each{|e| @export.push e}
      end
    end
  end
end

require "node/n-filter"
require "node/n-single-exportable"

module Fairy
  class NZipper<NSingleExportFilter
    Processor.def_export self

    DeepConnect.def_single_method_spec(self, "REF new(REF, VAL, VAL, VAL)")

    def initialize(processor, bjob, opts, block_source)
      super
      @block_source = block_source
#      @map_proc = eval("proc{#{@block_source}}", TOPLEVEL_BINDING)
#      @map_proc = @context.create_proc(@block_source)

      @zip_imports = nil
      @zip_imports_mutex = Mutex.new
      @zip_imports_cv = ConditionVariable.new
    end

    def zip_imports
      @zip_imports_mutex.synchronize do
	while !@zip_imports
	  @zip_imports_cv.wait(@zip_imports_mutex)
	end
      end
      @zip_imports
    end

    DeepConnect.def_method_spec(self, "VAL zip_imports")

    def zip_inputs=(zinputs)
      # 仮
      @zip_imports_mutex.synchronize do
	@zip_imports = zinputs.collect{|zinput| 
	  import = Import.new
	  import.no = zinput.no
	  import.add_key(zinput.key)
	  import
	}
	@zip_imports_cv.broadcast
      end
      @zip_imports
    end
    DeepConnect.def_method_spec(self, :rets => "VAL", :method => :zip_inputs=, :args => "VAL")

    def start
      super do
	@map_proc = BBlock.new(@block_source, @context, self)
	@import.each do |e|
	  zips = zip_imports.collect{|import| import.pop}
	  @export.push @map_proc.yield(e, *zips)
	end
      end
    end
  end
end

require "node/njob"
require "node/port"
require "node/n-single-exportable"

module Fairy
  class NFile<NSingleExportInput
    Processor.def_export self

    def NFile.open(processor, bjob, opts, fn)
      nfile = NFile.new(processor, bjob, opts)
      nfile.open(fn)
    end

    def initialize(processor, bjob, opts=nil)
      super
      @file = nil
    end

    def open(file_name)
      @file_name = file_name
      @file = File.open(file_name)
      start
      self
    end

    def start
      super do
	for l in @file
	  @export.push l
	end
	@file.close
	@file = nil # FileオブジェクトをGCの対象にするため
      end
    end
  end
end

require "node/n-filter"
require "node/n-single-exportable"

module Fairy
  class NHere<NFilter
    Processor.def_export self

    include NSingleExportable

    def start
      super do
	@import.each do |e|
# 	  if e.__deep_connect_reference? && e.kind_of?(Array)
# 	    e = e.to_a
# 	  end
	  @export.push e
	end
      end
    end
  end
end

require "thread"

require "processor"
require "share/block-source"

module Fairy

  class NJob
    Processor.def_export self

    END_OF_STREAM = :END_OF_STREAM

    ST_INIT = :ST_INIT
    ST_ACTIVATE = :ST_ACTIVATE
    ST_FINISH = :ST_FINISH

    def initialize(processor, bjob, opts={}, *rests)
      Log::info self, "CREATE NJOB: #{self.class}"
      @processor = processor
      @bjob = bjob
      @opts = opts

      @main_thread = nil

      @context = Context.new(self)
#       @begin_block = nil
#       if @opts[:BEGIN]
# 	@begin_block = BBlock.new(@opts[:BEGIN], @context, self)
#       end
#       @end_block = nil
#       if @opts[:END]
# 	@end_block = BBlock.new(@opts[:END], @context, self)
#       end

      @begin_block_source = nil
      if @opts[:BEGIN]
	@begin_block_source = @opts[:BEGIN]
      end
      @end_block_source = nil
      if @opts[:END]
	@end_block_source = @opts[:END]
      end

      @no = nil
      @no_mutex = Mutex.new
      @no_cv = ConditionVariable.new

      @status = ST_INIT
      @status_mutex = Mutex.new
      @status_cv = ConditionVariable.new

      start_watch_status
    end

    attr_reader :processor
    
    def no=(no)
      @no = no
      @no_cv.broadcast
      @no
    end

    def no
      @no_mutex.synchronize do
	while !@no
	  @no_cv.wait(@no_mutex)
	end
	no
      end
    end

    def start(&block)
#      puts "START NJOB: #{self.class}"
      @main_thread = Thread.start{
	self.status = ST_ACTIVATE
	if @begin_block_source
	  bsource = BSource.new(@begin_block_source, @context, self)
	  bsource.evaluate
	end
	begin
	  block.call
	ensure
	  if @end_block_source
	    bsource = BSource.new(@end_block_source, @context, self)
	    bsource.evaluate
	  end
	  self.status = ST_FINISH
	end
      }
      nil
    end

    def global_break
      Thread.start{@bjob.break_running(self)}
      Thread.current.exit
      self.status = ST_FINISH
      # 他のスレッドはとめていない
    end

    def break_running
      @main_thread.exit
      self.status = ST_FINISH
      # 他のスレッドはとめていない
    end

    def status=(val)
      @status_mutex.synchronize do
	@status = val
	@status_cv.broadcast
      end
    end

    def start_watch_status
      # 初期状態通知
      notice_status(@status)

      Thread.start do
	old_status = nil
	loop do
	  @status_mutex.synchronize do
	    while old_status == @status
	      @status_cv.wait(@status_mutex)
	    end
	    old_status = @status
# puts "STATUS CHANGED: #{self} #{@status}"
	    notice_status(@status)
	  end
	end
      end
      nil
    end

