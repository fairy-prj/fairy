#!/usr/bin/env ruby
# encoding: UTF-8

# THIS FILE IS AUTO GENERATION.
# Don't modify this file.

require "optparse"

##Original from lib/fairy/share/conf.rb
# encoding: UTF-8
#
# Copyright (C) 2007-2010 Rakuten, Inc.
#

require "socket"
require "rbconfig"

module Fairy

  CONF_PATH = [
    "/etc/fairy.conf",
    RbConfig::CONFIG["libdir"]+"/fairy/etc/fairy.conf",
    ENV["FAIRY_HOME"] && ENV["FAIRY_HOME"]+"/etc/fairy.conf", 
    ENV["HOME"]+"/.fairyrc",
    ENV["FAIRY_CONF"]
  ]
#  $:.each{|p|
#    CONF_PATH.push p+"/fairy/etc/fairy.conf"
#  }

  class Conf
    PROPS = []
    class DefaultConf<Conf;end

    def initialize(super_conf = nil, opts = {})
      @super_conf = super_conf
      @values = opts
    end

    class<<Conf
      def def_prop(prop, reader = nil, setter = nil)
	PROPS.push prop
	reader = "def #{prop}; value(:#{prop}); end" unless reader
	setter = "def #{prop}=(value); @values[:#{prop}] = value; end" unless setter
	module_eval reader
	module_eval setter
#	DefaultConf.module_eval reader
      end

      def def_prop_relative_path(prop, path, base_prop = :HOME)
	def_prop(prop, 
		 "def #{prop}; value(:#{prop}) || self.#{base_prop}+'/'+'#{path}'; end")
      end
      alias def_rpath def_prop_relative_path
    end

    def value(prop)
      if (v = @values[prop]).nil?
	@super_conf && v = @super_conf.value(prop)
      end
      v
    end

    def props
      PROPS
    end

    def base_conf=(conf)
      if @super_conf
	@super_conf.base_conf = conf
      else
	@super_conf = conf
      end
    end

    def set_values(hash)
      for key, value in hash
	@values[key] = value
      end
    end

    def_prop :RUBY_BIN
    def_prop :MASTER_HOST
    def_prop :MASTER_PORT

    def_prop :HOME
    def HOME
      File.expand_path(value(:HOME))
    end

    def_rpath :BIN, "bin"
    def_rpath :LIB, "lib"
    def_rpath :SUBCMD, "subcmd", :BIN
    def_rpath :CONTROLLER_BIN, "controller", :SUBCMD
    def_rpath :PROCESSOR_BIN, "processor", :SUBCMD

    def_prop :DEFAULT_EXTERNAL
    def_prop :DEFAULT_INTERNAL

    def_prop :IGNORE_EXCEPTION_ON_FILTER

    def_prop :MASTER_MAX_ACTIVE_PROCESSORS

    def_prop :CONTROLLER_INPUT_PROCESSOR_N
    def_prop :CONTROLLER_MAX_ACTIVE_TASKS_IN_PROCESSOR

    def_prop :CONTROLLER_ASSIGN_NEW_PROCESSOR_N_FACTOR

    def_prop :PREQUEUING_POLICY
    def_prop :POSTQUEUING_POLICY

    def_prop :POSTMAPPING_POLICY

    def_prop :POSTQUEUE_MAX_TRANSFER_SIZE
    def_prop :POOLQUEUE_POOL_THRESHOLD
    def_prop :ONMEMORY_SIZEDQUEUE_SIZE
    def_prop :FILEBUFFEREDQUEUE_THRESHOLD

    def_prop :MARSHAL_QUEUE_CHUNK_SIZE
    def_prop :MARSHAL_QUEUE_MIN_CHUNK_NO
    def_prop :SIZEDMARSHAL_QUEUE_MAX_CHUNK_NO

    def_prop :SORTEDQUEUE_POOL_THRESHOLD
    def_prop :SORTEDQUEUE_THRESHOLD
    def_prop :SORTEDQUEUE_SORTBY

    def_prop :INPUT_LOCAL_FILE_BUFFER_SIZE
    def_prop :HERE_POOL_THRESHOLD
    #def_prop :OUTPUT_LOCAL_POOL_THRESHOLD

    def_prop :GROUP_BY_NO_SEGMENT
    def_prop :GROUP_BY_HASH_MODULE
    def_prop :GROUP_BY_GROUPING_OPTIMIZE

    def_prop :GROUP_BY_BUFFERING_POLICY
    def_prop :GROUP_BY_CMSB_THRESHOLD
    def_prop :GROUP_BY_CMSB_CHUNK_SIZE

    def_prop :BARRIER_MEMORY_BUFFERING_POLICY

    def_prop :SORT_BUFFERING_POLICY
    def_prop :SORT_SAMPLING_MIN
    def_prop :SORT_SAMPLING_MAX
    def_prop :SORT_SAMPLING_RATIO_1_TO
    def_prop :SORT_NO_SEGMENT
    def_prop :SORT_CMP_OPTIMIZE

    def_prop :IOTA_SPLIT_NO

    def_prop :TRANSFAR_MARSHAL_STRING_ARRAY_OPTIMIZE

    def_rpath :VF_ROOT, "Repos"
    def_prop :VF_PREFIX
    def_prop :VF_BASE_NAME_CONVERTER
    def_prop :VF_SPLIT_SIZE

    def_prop :TMP_DIR

    def_prop :LOG_FILE
    def_prop :LOG_LEVEL
    def_prop :LOG_FLUSH_INTERVAL
    def_prop :LOG_MARK_INTERVAL
    def_prop :LOG_IMPORT_NTIMES_POP
    def_prop :LOG_LOCAL_OUTPUT_DEV 
    def_prop :LOG_ROTATE_INTERVAL
    def_prop :LOG_ROTATE_N

    def_prop :SUBCMD_EXEC_TIMEOUT

    def_prop :PROCESSOR_MON_ON
    def_prop :PROCESSOR_MON_INTERVAL
    def_prop :PROCESSOR_MON_PSFORMAT
    def_prop :PROCESSOR_MON_OBJECTSPACE_INSPECT_ON

    def_prop :SOCK_DO_NOT_REVERSE_LOOKUP
    def_prop :USE_RESOLV_REPLACE
    
    def_prop :BLOCK_USE_STDOUT

    def_prop :DEBUG_PORT_WAIT
    def_prop :DEBUG_FULL_BACKTRACE
    def_prop :DEBUG_THREAD_ABORT_ON_EXCEPTION
    def_prop :DEBUG_MONITOR_ON
    def_prop :DEBUG_PROCESSOR_TRACE_ON
    def_prop :DEBUG_BUG49 

    def_prop :BUG234

    def_prop :PROCESS_LIFE_MANAGE_INTERVAL

    def_prop :THREAD_STACK_SIZE

#     class JobConf<Conf
#       def initialize(prefix = "", super_conf = nil, opts ={})
# 	@prefix = prefix.upcase
#       end

#       def method_missing(method, *args, &b)
# 	del = "#{prefix}_#{method.id2name.upcase}"
# 	if respond_to?(del)
# 	  __send__(del, *args, &b) 
# 	else
# 	  super
# 	end
#       end
#     end
#     BJobConf = JobConf
#     NJobConf = JobConf

    class DefaultConf

      def initialize
	super

	@default_host = `hostname`.chomp
	@hosts = {}
      end

      def [](host)
	unless @hosts[host]
	  @hosts[host] = Conf.new
	end
	@hosts[host]
      end

      def value(prop)
	conf = @hosts[@default_host]
	v = conf && conf.value(prop)
	return v if v
	@values[prop]
      end

      def load_all_conf
	loaded = false
	for path in CONF_PATH
	  if path
	    if File.exist?(path)
	      load_conf path
	      loaded = true
	    end
	  end
	end
#	unless loaded
#	  puts "warnfairy.confファイルが見つかりません"
#	end
      end

      def load_conf(conf)
	begin
	  load conf
	rescue LoadError
	  puts "設定ファイル #{conf} をロードできませんでした."
	  exit 1
	rescue
	  puts "設定ファイル #{@conf} をロード中に例外が発生しました."
	  p $!
	  p $@
	  exit 2
	end
      end
    end
  end

  DEFAULT_CONF = Conf::DefaultConf.new
  
  DEFAULT_CONF.RUBY_BIN = ENV["FAIRY_RUBY"] || "ruby" 

  #DEFAULT_CONF.MASTER_HOST = 
  DEFAULT_CONF.MASTER_PORT = 19999

#  DEFAULT_CONF.HOME = ENV["FAIRY_HOME"] || "/usr/lib/fairy"
  home = ENV["FAIRY_HOME"] 
  unless home
    home = File.dirname(File.dirname(File.expand_path(__FILE__)))
    if File.basename(__FILE__) == "conf.rb"
      home = File.dirname(File.dirname(home))
    end
  end
  DEFAULT_CONF.HOME = home
#  DEFAULT_CONF.BIN = DEFAULT_CONF.HOME+"/bin"
#  DEFAULT_CONF.LIB = DEFAULT_CONF.HOME+"/lib"

#  DEFAULT_CONF.CONTROLLER_BIN = DEFAULT_CONF.BIN+"/controller"
#  DEFAULT_CONF.PROCESSOR_BIN = DEFAULT_CONF.BIN+"/processor"

  DEFAULT_CONF.DEFAULT_EXTERNAL = nil
  DEFAULT_CONF.DEFAULT_INTERNAL = nil

  DEFAULT_CONF.IGNORE_EXCEPTION_ON_FILTER = false

  DEFAULT_CONF.MASTER_MAX_ACTIVE_PROCESSORS = 4

  DEFAULT_CONF.CONTROLLER_INPUT_PROCESSOR_N = 10
  DEFAULT_CONF.CONTROLLER_MAX_ACTIVE_TASKS_IN_PROCESSOR = 4

  DEFAULT_CONF.CONTROLLER_ASSIGN_NEW_PROCESSOR_N_FACTOR = 1

  DEFAULT_CONF.POSTMAPPING_POLICY = nil

  DEFAULT_CONF.PREQUEUING_POLICY = {:queuing_class => :FileMarshaledQueue}
  DEFAULT_CONF.POSTQUEUING_POLICY = {:queuing_class => :FileMarshaledQueue}

  DEFAULT_CONF.POSTQUEUE_MAX_TRANSFER_SIZE = 100000
  DEFAULT_CONF.POOLQUEUE_POOL_THRESHOLD = 10000
  DEFAULT_CONF.ONMEMORY_SIZEDQUEUE_SIZE = 10000
  DEFAULT_CONF.FILEBUFFEREDQUEUE_THRESHOLD = 10000/2

  DEFAULT_CONF.MARSHAL_QUEUE_CHUNK_SIZE = DEFAULT_CONF.POOLQUEUE_POOL_THRESHOLD
  DEFAULT_CONF.MARSHAL_QUEUE_MIN_CHUNK_NO = DEFAULT_CONF.POOLQUEUE_POOL_THRESHOLD
  DEFAULT_CONF.SIZEDMARSHAL_QUEUE_MAX_CHUNK_NO = 10
  
  DEFAULT_CONF.SORTEDQUEUE_POOL_THRESHOLD = DEFAULT_CONF.POOLQUEUE_POOL_THRESHOLD
  DEFAULT_CONF.SORTEDQUEUE_THRESHOLD = 10000/2
  DEFAULT_CONF.SORTEDQUEUE_SORTBY = %{|v| v}

  DEFAULT_CONF.INPUT_LOCAL_FILE_BUFFER_SIZE = 1024*1024
  DEFAULT_CONF.HERE_POOL_THRESHOLD = 32000
  #DEFAULT_CONF.OUTPUT_LOCAL_POOL_THRESHOLD = 32000

  DEFAULT_CONF.GROUP_BY_NO_SEGMENT = 4
  DEFAULT_CONF.GROUP_BY_HASH_MODULE = "fairy/share/hash-md5"
  DEFAULT_CONF.GROUP_BY_GROUPING_OPTIMIZE = false

  DEFAULT_CONF.GROUP_BY_BUFFERING_POLICY = {:buffering_class => :DirectMergeSortBuffer}
  DEFAULT_CONF.GROUP_BY_CMSB_THRESHOLD = 400_000
  DEFAULT_CONF.GROUP_BY_CMSB_CHUNK_SIZE = 1000

  DEFAULT_CONF.BARRIER_MEMORY_BUFFERING_POLICY = {:queuing_class => :PoolQueue}

  DEFAULT_CONF.SORT_BUFFERING_POLICY = {:buffering_class => "PGroupBy::DirectMergeSortBuffer"}
  DEFAULT_CONF.SORT_SAMPLING_MIN = 100
  DEFAULT_CONF.SORT_SAMPLING_MAX = 10000
  DEFAULT_CONF.SORT_SAMPLING_RATIO_1_TO = 100
  DEFAULT_CONF.SORT_NO_SEGMENT = DEFAULT_CONF.GROUP_BY_NO_SEGMENT
  DEFAULT_CONF.SORT_CMP_OPTIMIZE = false

  DEFAULT_CONF.IOTA_SPLIT_NO = 4

  DEFAULT_CONF.TRANSFAR_MARSHAL_STRING_ARRAY_OPTIMIZE = false

#  DEFAULT_CONF.VF_ROOT = DEFAULT_CONF.HOME+"/Repos"
  DEFAULT_CONF.VF_PREFIX = `hostname`.chomp
## DEFAULT_CONF.VF_PREFIX is client setting.
  DEFAULT_CONF.VF_BASE_NAME_CONVERTER = nil
  DEFAULT_CONF.VF_SPLIT_SIZE = 64*1024*1024

  DEFAULT_CONF.TMP_DIR = "/tmp/fairy/tmpbuf"

  DEFAULT_CONF.LOG_FILE = "/tmp/fairy/log"
  DEFAULT_CONF.LOG_FLUSH_INTERVAL = 1
  DEFAULT_CONF.LOG_MARK_INTERVAL = 300
  DEFAULT_CONF.LOG_LEVEL = :DEBUG
  DEFAULT_CONF.LOG_IMPORT_NTIMES_POP = 100000
  DEFAULT_CONF.LOG_LOCAL_OUTPUT_DEV = :$stderr
  DEFAULT_CONF.LOG_ROTATE_INTERVAL = 60*60*24
  DEFAULT_CONF.LOG_ROTATE_N = 7

  DEFAULT_CONF.SUBCMD_EXEC_TIMEOUT = 60

  DEFAULT_CONF.PROCESSOR_MON_ON = false
  DEFAULT_CONF.PROCESSOR_MON_INTERVAL = 300
  DEFAULT_CONF.PROCESSOR_MON_PSFORMAT = "stat,vsz,rss,sz,pmem,pcpu,nlwp,time,wchan"
  DEFAULT_CONF.PROCESSOR_MON_OBJECTSPACE_INSPECT_ON = false

  DEFAULT_CONF.SOCK_DO_NOT_REVERSE_LOOKUP = true
  DEFAULT_CONF.USE_RESOLV_REPLACE = false

  DEFAULT_CONF.BLOCK_USE_STDOUT = false

  DEFAULT_CONF.DEBUG_PORT_WAIT = false
  DEFAULT_CONF.DEBUG_FULL_BACKTRACE = false
  DEFAULT_CONF.DEBUG_THREAD_ABORT_ON_EXCEPTION = false
  DEFAULT_CONF.DEBUG_MONITOR_ON = false
  DEFAULT_CONF.DEBUG_PROCESSOR_TRACE_ON = false
  DEFAULT_CONF.DEBUG_BUG49 = false

  DEFAULT_CONF.BUG234 = false

# DEFAULT_CONF.PROCESS_LIFE_MANAGE_INTERVAL = 60
# DEFAULT_CONF.PROCESS_LIFE_MANAGE_INTERVAL = 10
# DEFAULT_CONF.PROCESS_LIFE_MANAGE_INTERVAL = 1
  DEFAULT_CONF.PROCESS_LIFE_MANAGE_INTERVAL = nil

#  DEFAULT_CONF.THREAD_STACK_SIZE = 1024*100

  CONF = DEFAULT_CONF
  CONF.load_all_conf

  def REPLACE_CONF(conf)
    remove_const(:CONF)
    const_set(:CONF, conf)
  end
  module_function :REPLACE_CONF

  
  def Conf.configure_common_conf
    Thread.abort_on_exception = CONF.DEBUG_THREAD_ABORT_ON_EXCEPTION

    TCPSocket.do_not_reverse_lookup = CONF.SOCK_DO_NOT_REVERSE_LOOKUP

    if CONF.USE_RESOLV_REPLACE
      require "resolv-replace"
    end
  end
end

##Original from lib/fairy/share/base-app.rb
# encoding: utf-8
#
# Copyright (C) 2007-2010 Rakuten, Inc.
#

module Fairy
  class BaseAPP
    
    def self.start
      @@APP = new
      @@APP.parse_arg
      @@APP.load_conf
      @@APP.configure_conf
      @@APP.start
    end

    def self.start_subcommand(prog, *opts)
      @@APP.start_subcommand(prog, *opts)
    end
    def self.start_subcommand2(prog, *opts)
      Process.fork do
	start_subcommand(prog, *opts)
      end
    end

    def initialize
      @home = nil
      @conf = nil
      @CONF = {}
    end

    def parse_arg
      @opt = option_parser
      @opt.order!(ARGV)
    end

    def option_parser
      opt = OptionParser.new{|opt|
	opt.on("--home=VAL"){|val| @home = val}
	opt.on("--conf=VAL"){|val| @conf = val}
	CONF.props.each do |prop|
	  opt.on("--CONF.#{prop}=VAL") {|val| @CONF[prop] = val}
	end
      }
      if block_given?
	yield opt
      end
    end

    def conf_to_arg
      @CONF.collect{|prop, source| "--CONF.#{prop}=#{source}"}
    end

    def load_conf
      if @home
	ENV["FAIRY_HOME"] = @home
#	ENV["FAIRY_HOME"] = File.expand_path(@home)
	conf = @home+"/etc/fairy.conf"
	if File.exists?(conf)
	  CONF.load_conf conf
	end
      end
	
      if @conf
	ENV["FAIRY_CONF"] = @conf
	CONF.load_conf @conf
      end

      @CONF.each do |key, value|
	begin
	  eval "CONF.#{key}=#{value}"
	rescue
	  puts "CONF.#{key}=#{value} が不正です."
	  exit 1
	end
      end
      if  ENV["RUBYLIB"]
	ENV["RUBYLIB"] = CONF.LIB + ":" + ENV["RUBYLIB"]
      else
	ENV["RUBYLIB"] = CONF.LIB
      end
    end

    def configure_conf
      Conf.configure_common_conf
    end

    def start
      ERR::Raise ERR::INTERNAL::ShouldDefineSubclass
    end

    def start_subcommand(prog, *opts)
      opts.push *conf_to_arg
#       Process.fork do
# 	Log.stop_export
# 	ObjectSpace.each_object(IO) do |io|
# 	  begin
# 	    if ![0, 1, 2].include?(io.fileno )
# 	      io.close
# 	    end
# 	  rescue
# 	  end
# 	end
# 	exec(prog, *opts)
#       end

      Process.spawn(prog, *opts)
#      system("#{prog} #{opts.join(' ')}&")

    end

  end
end


##Original from lib/fairy/template/fairy-BODY.templ
# -*- ruby -*-
#
# Copyright (C) 2007-2010 Rakuten, Inc.
#
#
module Fairy
#  LC_MESSAGES = IRB::Locale.new
#  LC_MESSAGES.load(CONF.LIB+"/fairy/share/exceptions.rb")
  class FairyAPP<BaseAPP

    SUBCOMMANDS = ["cp", "rm", "cat", "master", "node", "inspector"]

    def initialize
      super
      @mode = :SUBCOMMAND
    end

    def option_parser
      super do |opt|
	opt.on("-f", "--file"){|val| @mode = :FILE}
	opt.on("-e", "--exec"){|val| @mode = :EXEC}
      end
    end

    def start
      if @mode == :SUBCOMMAND && 
	  (ARGV.empty? || nosub = !SUBCOMMANDS.include?(ARGV[0]))
	puts "そのようなサブコマンドはありません(#{ARGV[0]})." if nosub

	helpbase = @opt.help.split(/\n/)
	helpbase[0].concat(" subcommand [subcommand-options]")
	helpbase.insert(1, "  Options:")
	helpbase.insert(1, 
			"  Subcommands:", 
			*SUBCOMMANDS.collect{|s| "    "+s})
			
	puts helpbase
	exit
      end

      case @mode
      when :SUBCOMMAND
	if File.exist?(CONF.SUBCMD+"/"+ARGV[0])
	  Process.exec(CONF.RUBY_BIN, CONF.SUBCMD+"/"+ARGV[0], *ARGV[1..-1])
	else
	  Process.exec(CONF.RUBY_BIN, CONF.BIN+"/fairy-"+ARGV[0], *ARGV[1..-1])
	end
      when :FILE
	Process.exec(CONF.RUBY_BIN, *ARGV)
      when :EXEC
	Process.exec(*ARGV)
      end
    end
  end
end

Fairy::FairyAPP.start


